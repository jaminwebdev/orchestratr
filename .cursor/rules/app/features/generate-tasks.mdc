# Rule: Feature Task Generation

## Goal

To guide an AI assistant in creating a detailed, step-by-step task list in Markdown for a single feature. This rule takes a feature-specific PRD as its primary input and cross-references the core project documentation in `/docs/` for context on architecture, design, and standards.

The purpose is to translate the feature's requirements into an actionable engineering plan that is ready for development, ensuring the new feature is implemented in full alignment with the existing product.

## Process

1.  **Receive PRD Input:** The user must provide the path to the feature-specific PRD generated by the `create-prd.mdc` rule (e.g., `/features/new-reporting/new-reporting_prd.md`).
2.  **Comprehensive Document Analysis:** The AI will analyze the provided feature PRD and cross-reference the core documents in `/docs/` to understand technical and design constraints (`04_design_guidelines.md`, `05_technical_architecture.md`).
3.  **Conduct Structured Discovery:** Use the clarifying questions below to resolve any ambiguities about the feature's implementation before generating tasks.
4.  **Generate High-Level Parent Tasks:** Synthesize all inputs to create high-level parent tasks, typically corresponding to the user stories or epics in the feature PRD.
5.  **User Confirmation:** Present the high-level plan and pause for user review. Prompt with:
    > "I've outlined the high-level tasks for implementing the [Feature Name] feature. Please review them. Are you ready to proceed with generating the detailed sub-tasks? Respond with 'Go' to continue."
6.  **Generate Detailed Sub-Tasks:** Upon receiving user confirmation ("Go"), generate the full task list with granular sub-tasks for each parent task.
7.  **Final Quality Assurance:** Use the `Quality Assurance Framework` to ensure the final task list is complete and actionable.
8.  **Save and Version:** Save the final task list in the same feature-specific directory (e.g., `/features/[feature-name]/tasks.md`).

## Discovery Framework

  * **Implementation Priority:** "Within this feature, are there any user stories that should be prioritized over others?"
  * **Feature Flag:** "Should this feature be developed behind a feature flag to allow for a gradual rollout?"
  * **Testing Scope:** "Are there specific performance or load testing requirements for this feature's new API endpoints?"
  * **Existing Code:** "Are there any existing components or services that should be refactored or reused for this feature?"

## Document Structure (for the output .md file)

The generated task list should follow this focused structure:

```markdown
# Task Breakdown: [Feature Name]

## 1. Overview
- **Goal:** [A one-sentence summary of the feature, referencing the feature PRD.]
- **PRD Link:** [Link to the source `[feature-name]_prd.md` file.]
- **Key Dependencies:** [List any blocking dependencies, e.g., "Requires an updated version of the main component library."]

## 2. Relevant Files & Setup
- **Prerequisites:** [List any specific setup steps, e.g., "Run `npm run seed:new-feature` to populate test data."]
- **Files to Modify/Create:**
    - `path/to/existing/component.tsx` - To add the new feature's entry point.
    - `path/to/new/feature_component.tsx` - The main component for this feature.
    - `path/to/new/feature_api.ts` - The new API route handler.

---

## 3. Tasks

- [ ] **1.0 Parent Task:** [User Story 1 from PRD]
    - [ ] 1.1 **Backend:** Add new columns to the `[table_name]` table with a migration script.
    - [ ] 1.2 **Backend:** Develop the `POST /api/v1/new-feature` endpoint with input validation.
    - [ ] 1.3 **Backend:** Write unit and integration tests for the new endpoint.
    - [ ] 1.4 **Frontend:** Build the `[NewFeatureForm]` component according to `04_design_guidelines.md`.
    - [ ] 1.5 **Frontend:** Connect the form to the new API endpoint and handle state management.
    - [ ] 1.6 **Testing:** Write end-to-end tests for the feature's "happy path."

- [ ] **2.0 Parent Task:** [User Story 2 from PRD]
    - [ ] 2.1 [Sub-task description 2.1]
    - [ ] 2.2 [Sub-task description 2.2]
```

## Quality Assurance Framework

  - [ ] Does the task list cover every **acceptance criterion** from the feature PRD?
  - [ ] Are all tasks aligned with the established patterns in the `05_technical_architecture.md` and `04_design_guidelines.md`?
  - [ ] Are tasks for testing included for every new piece of functionality (backend and frontend)?
  - [ ] Are the tasks granular enough for a developer to begin work without significant ambiguity?

## Integration with Other Documentation

  * **Primary Input:** A feature-specific PRD (e.g., `[feature-name]_prd.md`).
  * **Contextual Inputs:** The core project documents in `/docs/`, especially for architecture, design, and coding standards.
  * **Output:** A task list (`tasks.md`) that will be the input for the `iterate-tasks.mdc` rule, which will carry out the development.

## Best Practices

1.  **Scope Adherence:** All tasks must directly correspond to requirements within the feature PRD.
2.  **Atomic Tasks:** Break work down into the smallest reasonable units to facilitate progress tracking and code reviews.
3.  **Reference, Don't Repeat:** Keep tasks concise and, where necessary, link back to the PRD or design guidelines for more detail.

## Output Requirements

  - **Format:** Markdown (`.md`) with checkboxes.
  - **Location:** `/features/[feature-name]/`
  - **Filename:** `tasks.md`
  - **Audience:** The developer(s) responsible for implementing the feature.

## Final Instructions

1.  **DO NOT** generate tasks for anything listed in the "Out of Scope" section of the PRD.
2.  **DO** create separate, explicit tasks for writing code, writing tests, and any required documentation updates.
3.  **DO** ensure the task sequence is logical and respects dependencies.

## Key Success Factors

1.  **Clarity:** A developer can understand the full scope of work for the feature from this single file.
2.  **Traceability:** Every task can be easily traced back to a specific requirement in the feature PRD.
3.  **Consistency:** The implementation plan ensures the new feature will be built using the same standards and patterns as the rest of the application.